# @staticimports pkg:staticimports
#   is_string cat0

# @staticimports pkg:staticimports
#   map_chr walk

#' Statically import objects
#'
#' @description
#'
#' This function finds staticimports declarations and copies the objects to a
#' target file.
#'
#' staticmports declartions are comment blocks that look like this:

#'
#' ```
#' # @staticimports pkg:staticimports
#' #   map map_chr map_lgl os_name any_named any_unnamed
#' #   all_named all_unnamed
#' ```

#'
#' The `pkg:staticimports` means to import objects from the package named
#' **staticimports**. If you use `pkg:mypackage`, it will import from
#' **mypackage**.
#'
#' On the following lines are the names of the objects to import.
#'

#'
#' The import declaration can also use a path. For example:
#'
#' ```
#' # @staticimports ../mystaticexports
#' #   map map_chr map_lgl os_name any_named any_unnamed
#' #   all_named all_unnamed
#' ```

#'
#' If a relative path is used, it will be relative to the top-leve of this
#' project, as determined by [here::here()].
#'
#' The statically imported objects are written a file, by default
#' `R/staticimports.R`.
#'
#' @param dir A directory containing .R files to scan for import declarations.
#' @param outfile File to write to. Defaults to R/staticimports.R in the current
#'   project. Use `stdout()` to output to console.
#'
#' @export
import <- function(
  dir     = here::here("R/"),
  outfile = here::here("R/staticimports.R")
)
{
  imports <- find_staticimports(dir)

  file.remove(outfile)
  for (import in imports) {
    import_objs(
      names   = import$names,
      source  = import$source,
      outfile = outfile,
      append   = TRUE
    )
  }
}


#' Statically import specific objects
#'
#' @inheritParams import
#' @param names A character vector of names of objects to import.
#' @param source A directory containing source files, or an environment to use
#'   as the source.
#' @param append If `TRUE`, append to the output file; otherwise overwrite.
#'
#' @examples
#' if (interactive()) {
#' # Import `os_name` and `walk` into your project
#' import_objs(c("os_name", "walk"))
#' }
#'
#' # Write to stdout instead of R/staticimports.R
#' import_objs(c("os_name", "walk"), stdout())
#' @export
import_objs <- function(
  names,
  source  = system.file("staticexports", package = "staticimports"),
  outfile = here::here("R/staticimports.R"),
  append = FALSE
) {
  if (is.environment(source)) {
    env <- source
  } else {
    env <- new.env()
    files <- dir(source, pattern = "\\.[r|R]$", full.names = TRUE)
    for (file in files) {
      source(file, local = env, keep.source = TRUE)
    }
  }

  dep_table <- find_internal_deps(env)
  all_dep_names <- c(names, unlist(dep_table[names], recursive = FALSE, use.names = FALSE))
  all_dep_names <- sort(unique(all_dep_names))

  all_dep_objs <- mget(all_dep_names, env)

  # Get the source text for a function.
  get_src_text <- function(obj, name) {
    srcref <- attr(obj, "srcref")
    if (is.null(srcref)) {
      if (is.function(obj)) {
        message(
          "Note: can't get srcref for `", name,
          "`. Package should be installed with source refs. Using `deparse()` instead."
        )
      }
      return(deparse(obj))
      # return("NULL  # Note: no srcref was available for this object")
    }
    as.character(srcref)
  }

  # Given a list of functions (with source refs), write the source to a file.
  write_deps <- function(fns, outfile) {
    if (is_string(outfile)) message("Writing to ", outfile)

    cat("# Generated by staticimports; do not edit by hand.\n", file = outfile)

    for (i in seq_along(fns)) {
      fn_name <- names(fns)[i]
      cat0(
        "\n",
        # Ensure that names with weird characters, like %||%, get backticks,
        # like `%||%`.
        capture.output(print(as.symbol(fn_name))),
        " <- ",
        paste0(get_src_text(fns[[i]], fn_name), collapse = "\n"),
        "\n",
        file = outfile,
        append = TRUE
      )
    }
  }

  write_deps(all_dep_objs, outfile)
}



#' Find any static imports in the comments of the R/ directory
#'
#' This finds staticimports declarations, which are comment blocks that look
#' like:
#'
#' ```
#' # @staticimports pkg:staticimports
#' #   map map_chr map_lgl os_name any_named any_unnamed
#' #   all_named all_unnamed
#' ```
#'
#' @param dir A directory to look in. Defaults to
#'
#' @return A list of lists. Each sub-list has a `source` field and `names`.
#'
#' @export
find_staticimports <- function(dir = here::here("R/")) {
  files <- dir(dir, pattern = "\\.[r|R]$", full.names = TRUE)

  comment_blocks <- lapply(files, function(file) {
    text <- readLines(file)
    match_line_idxs <- grep("^#\\s+@staticimports", text)
    if (length(match_line_idxs) == 0) {
      return(NULL)
    }

    comment_blocks <- list()
    # Find any lines after this that start with #
    comment_start_line_idxs <-  grep("^#", text)
    for (i in seq_along(match_line_idxs)) {
      match_line_idx <- match_line_idxs[[i]]
      comment_block_lines <- text[[match_line_idx]]

      j <- match_line_idx + 1
      while (j %in% comment_start_line_idxs) {
        comment_block_lines[length(comment_block_lines) + 1] <- text[[j]]
        j <- j + 1
      }

      comment_blocks[[i]] <- list(
        file = file,
        start_line = match_line_idx,
        text = comment_block_lines
      )
    }

    comment_blocks
  })

  comment_blocks <- unlist(comment_blocks, recursive = FALSE)

  imports <- lapply(comment_blocks, function(block) {
    # First line of each block starts is "# @staticimports xxxxx"
    first <- block$text[[1]]
    source <- sub("^#\\s+@staticimports\\s+", "", first)
    source <- sub("\\s+$", "", source)

    if (!grepl("^\\S+$", source)) {
      stop(
        'staticimports spec does not have format "# @staticimports xxxxx" ',
        'in ', block$file, ", ", "line ", block$start_line, ":\n",
        first
      )
    }

    lines <- sub("^#", "", block$text[-1])
    names <- unique(unlist(strsplit(lines, " +")))
    names <- setdiff(names, "")

    list(
      source = source,
      names = names
    )
  })


  # Merge together staticimport specifications that come from the same file.
  sources <- unique(map_chr(imports, "source"))
  # Use radix to ensure consistent sorting across locales.
  sources <- sort(sources, method = "radix")
  imports <- lapply(sources, function(source) {
    names <- lapply(imports, function(x) {
      if (x$source == source) x$names
      else                    NULL
    })

    list(
      source = source,
      names = unlist(names)
    )
  })

  # Convert "pkg:foo" to the path in the package.
  imports <- lapply(imports, function(x) {
    if (grepl("^pkg:\\S+$", x$source)) {
      pkg_name <- sub("^pkg:", "", x$source)
      x$source <- system.file("staticexports", package = pkg_name)
    } else {
      x$source <- here::here(x$source)
      x$source <- normalizePath(x$source)
    }
    x
  })

  imports
}

# @staticimports pkg:staticimports
#   is_string cat0
#   map_chr walk

#' Statically import objects
#'
#' @description
#'
#' This function finds staticimports declarations and copies the objects to a
#' target file.
#'
#' staticmports declartions are comment blocks that look like this:

#'
#' ```
#' # @staticimports pkg:staticimports
#' #   map map_chr map_lgl os_name any_named any_unnamed
#' #   all_named all_unnamed
#' ```

#'
#' The `pkg:staticimports` means to import objects from the package named
#' **staticimports**. If you use `pkg:mypackage`, it will import from
#' **mypackage**.
#'
#' On the following lines are the names of the objects to import.
#'

#'
#' The import declaration can also use a path. For example:
#'
#' ```
#' # @staticimports ../mystaticexports
#' #   map map_chr map_lgl os_name any_named any_unnamed
#' #   all_named all_unnamed
#' ```

#'
#' If a relative path is used, it will be relative to the top-leve of this
#' project, as determined by [here::here()].
#'
#' The statically imported objects are written a file, by default
#' `R/staticimports.R`.
#'
#' @param dir A directory containing .R files to scan for import declarations.
#' @param outfile File to write to. Defaults to R/staticimports.R in the current
#'   project. Use `stdout()` to output to console.
#'
#' @export
import <- function(
  dir     = here::here("R/"),
  outfile = here::here("R/staticimports.R")
)
{
  imports <- find_staticimports(dir)

  if (is.character(outfile)) {
    file.remove(outfile)
  }
  for (import in imports) {
    import_objs(
      names   = import$names,
      source  = import$path,
      outfile = outfile,
      label   = import$label,
      append  = TRUE
    )
  }
}


#' Statically import specific objects
#'
#' @inheritParams import
#' @param names A character vector of names of objects to import.
#' @param source A directory containing source files, or an environment to use
#'   as the source.
#' @param label A label to write to the file, to indicate where the objects were
#'   imported from.
#' @param append If `TRUE`, append to the output file; otherwise overwrite.
#'
#' @examples
#' if (interactive()) {
#' # Import `os_name` and `walk` into your project
#' import_objs(c("os_name", "walk"))
#' }
#'
#' # Write to stdout instead of R/staticimports.R
#' import_objs(c("os_name", "walk"), outfile = stdout())
#' @export
import_objs <- function(
  names,
  source  = system.file("staticexports", package = "staticimports"),
  outfile = here::here("R/staticimports.R"),
  label   = NULL,
  append  = FALSE
) {
  if (is.environment(source)) {
    env <- source
  } else {
    env <- new.env()
    files <- dir(source, pattern = "\\.[r|R]$", full.names = TRUE)
    source_text <- list() # The contents of each file
    for (file in files) {
      source(file, local = env, keep.source = TRUE)
      source_text[[file]] <- readLines(file)
    }
  }

  dep_table <- find_internal_deps(env)
  all_dep_names <- c(names, unlist(dep_table[names], recursive = FALSE, use.names = FALSE))
  all_dep_names <- sort(unique(all_dep_names))

  all_dep_objs <- mget(all_dep_names, env)

  all_source_text <- process_source_texts(source_text)

  # Given a list of functions (with source refs), write the source to a file.
  write_deps <- function(fns, outfile) {
    if (is_string(outfile)) message("Writing to ", outfile)

    cat(paste(
      sep = "",
      "# Generated by staticimports; do not edit by hand.\n",
      "# ======================================================================\n",
      if (!is.null(label)) {
        paste0(
          "# Imported from ", label, "\n",
          "# ======================================================================\n",
          sep = ""
        )
      }
    ), file = outfile, append = append)

    for (i in seq_along(fns)) {
      fn_name <- names(fns)[i]
      fn_txt <- all_source_text[[fn_name]]
      if (is.null(fn_txt)) {
        stop("Source for `", fn_name, "` not found.")
      }

      cat0(
        "\n",
        paste0(fn_txt, collapse = "\n"),
        "\n",
        file = outfile,
        append = TRUE
      )
    }
  }

  write_deps(all_dep_objs, outfile)
}


#' Find any static imports in the comments of the R/ directory
#'
#' This finds staticimports declarations, which are comment blocks that look
#' like:
#'
#' ```
#' # @staticimports pkg:staticimports
#' #   map map_chr map_lgl os_name any_named any_unnamed
#' #   all_named all_unnamed
#' ```
#'
#' @param dir A directory to look in. Defaults to
#'
#' @return A list of lists. Each sub-list has a `source` field and `names`.
#'
#' @export
find_staticimports <- function(dir = here::here("R/")) {
  files <- dir(dir, pattern = "\\.[r|R]$", full.names = TRUE)

  comment_blocks <- lapply(files, function(file) {
    text <- readLines(file)
    match_line_idxs <- grep("^#\\s+@staticimports", text)
    if (length(match_line_idxs) == 0) {
      return(NULL)
    }

    comment_blocks <- list()
    # Find any lines after this that start with #
    comment_start_line_idxs <-  grep("^#", text)
    for (i in seq_along(match_line_idxs)) {
      match_line_idx <- match_line_idxs[[i]]
      comment_block_lines <- text[[match_line_idx]]

      j <- match_line_idx + 1
      while (j %in% comment_start_line_idxs) {
        comment_block_lines[length(comment_block_lines) + 1] <- text[[j]]
        j <- j + 1
      }

      comment_blocks[[i]] <- list(
        file = file,
        start_line = match_line_idx,
        text = comment_block_lines
      )
    }

    comment_blocks
  })

  comment_blocks <- unlist(comment_blocks, recursive = FALSE)

  imports <- lapply(comment_blocks, function(block) {
    # First line of each block starts is "# @staticimports xxxxx"
    first <- block$text[[1]]
    source <- sub("^#\\s+@staticimports\\s+", "", first)
    source <- sub("\\s+$", "", source)

    if (!grepl("^\\S+$", source)) {
      stop(
        'staticimports spec does not have format "# @staticimports xxxxx" ',
        'in ', block$file, ", ", "line ", block$start_line, ":\n",
        first
      )
    }

    lines <- sub("^#", "", block$text[-1])
    names <- unique(unlist(strsplit(lines, " +")))
    names <- setdiff(names, "")

    list(
      source = source,
      names = names
    )
  })


  # Merge together staticimport specifications that come from the same file.
  sources <- unique(map_chr(imports, "source"))
  # Use radix to ensure consistent sorting across locales.
  sources <- sort(sources, method = "radix")
  imports <- lapply(sources, function(source) {
    names <- lapply(imports, function(x) {
      if (x$source == source) x$names
      else                    NULL
    })

    list(
      source = source,
      names = sort(unlist(names), method = "radix")
    )
  })

  # Convert "pkg:foo" to the path in the package.
  imports <- lapply(imports, function(x) {
    if (grepl("^pkg:\\S+$", x$source)) {
      pkg_name <- sub("^pkg:", "", x$source)
      source_path <- system.file("staticexports", package = pkg_name)
    } else {
      source_path <- here::here(x$source)
      source_path <- normalizePath(source_path)
    }

    list(
      label = x$source,
      path  = source_path,
      names = x$names
    )
  })

  imports
}




# Given a list of char vectors (each should be the output of `readLines()`),
# process the text and return a named list of objects.
process_source_texts <- function(source_texts) {
  results <- lapply(source_texts, process_source_text_one)
  do.call(c, unname(results))
}


# Given a char vector of lines (from readLines()), process the text and return a
# named list of objects.
process_source_text_one <- function(text) {
  # There are three states for this state machine:
  # - "SCANNING": This means we're looking for comments or object definitions.
  # - "OBJECT_DEFINITION": We're inside an object definition (usually a
  #     function).
  # - "LEADING_COMMENT": We're in a comment that (probably) precedes an object
  #     definition.
  chunks <- list()

  state <- "SCANNING"
  current_chunk <- character(0)
  current_chunk_name <- NULL
  for (line in text) {
    if (state == "SCANNING") {
      if (grepl("^\\S+ *<-", line)) {
        # Lines that start with "foo <-" tell us that the object definition
        # starts here.
        state <- "OBJECT_DEFINITION"
        current_chunk[length(current_chunk) + 1] <- line
        current_chunk_name <- sub("^(\\S+).*", "\\1", line)

        # Remove backticks, so that strings like "`%||%`" are converted to "%||%"
        if (grepl("^`\\S+`$", current_chunk_name)) {
          current_chunk_name <- sub("^`(\\S+)`$", "\\1", current_chunk_name)
        }

      } else if (grepl("^#", line)) {
        state <- "LEADING_COMMENT"
        current_chunk[length(current_chunk) + 1] <- line
      }

    } else if (state == "OBJECT_DEFINITION") {
      current_chunk[length(current_chunk) + 1] <- line
      if (grepl("^\\S", line)) {
        # If the line starts with anything _other_ than whitespace, then we know
        # we've reached the end of the object definition.
        state <- "SCANNING"
        chunks[[current_chunk_name]] <- current_chunk
        current_chunk <- character(0)
        current_chunk_name <- NULL
      }

    } else if (state == "LEADING_COMMENT") {
      if (grepl("^\\S+ *<-", line)) {
        # Lines that start with "foo <-" tell us that the object definition
        # starts here.
        state <- "OBJECT_DEFINITION"
        current_chunk[length(current_chunk) + 1] <- line
        current_chunk_name <- sub("^(\\S+).*", "\\1", line)

      } else if (grepl("^#", line)) {
        # Stay in current state.
        current_chunk[length(current_chunk) + 1] <- line

      } else {
        # We've hit the end of a comment block but no definition here. Just
        # discard the block and go back to scanning mode.
        state <- "SCANNING"
        current_chunk <- character(0)

      }
    }
  }

  chunks
}
